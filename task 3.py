# Задача 3. Кэширование для ускорения вычислений
# Контекст
# Вы разрабатываете программу для оптимизации вычислений чисел Фибоначчи.
# Числа Фибоначчи вычисляются рекурсивной функцией, каждое число равно сумме двух предыдущих чисел.
# Однако вы заметили, что при больших значениях чисел Фибоначчи вычисления занимают значительное время,
# так как многие значения вычисляются повторно.
# Вам поручено создать декоратор, который кэширует результаты вызова функции и позволяет избежать
# повторных вычислений для одних и тех же аргументов.
#
# Задача
# Создайте декоратор, который кэширует (сохраняет для дальнейшего использования) результаты вызова функции и,
# при повторном вызове с теми же аргументами, возвращает сохранённый результат.
#
# Примените его к рекурсивной функции вычисления чисел Фибоначчи.
# В итоге декоратор должен проверять аргументы, с которыми вызывается функция
# , и, если такие аргументы уже использовались, должен вернуть сохранённый результат вместо запуска расчёта.
#
# Советы
# - Для хранения результатов удобно использовать словарь,
# так как поиск элементов внутри словаря будет иметь сложность, равную в среднем O(1).
# - При этом не стоит хранить все вычисления в одном словаре,
# созданном снаружи функций (в глобальной области видимости). Лучше создавать
#  отдельные словари для каждой декорируемой функции.
def memoize(func):
    cache = {}  # Создаем словарь для кэширования результатов

    def wrapper(*args):
        if args not in cache:
            # Если результат для данных аргументов еще не кэширован, вычисляем и сохраняем
            cache[args] = func(*args)
        return cache[args]

    return wrapper
@memoize
def fibonacci(n):
    if n <= 0:
        print("Пожалуйста, введите положительное целое число.")
        return None  # Возвращаем None, чтобы не возвращать ненужное значение

    elif n == 1:
        return [0]
    elif n == 2:
        return [0, 1]
    else:
        sequence = [0, 1]
        for _ in range(n - 2):
            sequence.append(sequence[-1] + sequence[-2])

        return sequence

# Получаем от пользователя количество чисел Фибоначчи, которые нужно вычислить
try:
    n = int(input("Введите количество чисел Фибоначчи: "))
    result = fibonacci(n)

    if result is not None:
        print("Числа Фибоначчи:")

        # Выводим результат по 5 чисел в строке
        for i, value in enumerate(result, 1):
            print(value, end="\t")
            if i % 5 == 0:
                print()  # Переход на новую строку после каждых 5 чисел

except ValueError:
    print("Пожалуйста, введите целое число.")
